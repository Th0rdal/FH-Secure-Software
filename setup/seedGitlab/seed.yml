---
- name: Bootstrap GitLab & Shared Runner
  hosts: localhost
  connection: local
  gather_facts: false

  vars:
    new_gitlab_root_password: "2ada54772a7bb!"
    gitlab_base_url: "http://gitlab" # interne URL
    gitlab_container_name: "gitlab"
    ansible_python_interpreter: "{{ ansible_playbook_python }}"
    riddle_username: "riddle"
    riddle_user_password: "sadfsadf32!"
    riddle_email: "riddle@local.lab"
    puzzle_projects:
      - name: "riddle-01-start"
        path: "riddle-01"
      - name: "riddle-02-ci-key"
        path: "riddle-02"
      - name: "riddle-03-deploy"
        path: "riddle-03"
    # Zielpfad für die .env-Datei. '/project' ist dein '.'-Verzeichnis.
    runner_env_path: "/project/seedGitlab/runner.env"
    compose_chdir: "/project"

  tasks:
    # --- Dein bestehender Task zum Ändern des Passworts ---
    - name: Change root password via rails runner (through Docker API)
      community.docker.docker_container_exec:
        container: "{{ gitlab_container_name }}"
        env:
          NEWPW: "{{ new_gitlab_root_password }}"
        command: >-
          gitlab-rails runner "u = User.find_by_username('root'); u.password = ENV['NEWPW'];
          u.password_confirmation = ENV['NEWPW']; u.save!; puts 'OK'"
      register: exec_out

    - name: Mark changed only when OK appears
      ansible.builtin.set_fact:
        _changed: "{{ 'OK' in (exec_out.stdout | default('')) }}"
      changed_when: _changed
      failed_when: exec_out.rc|default(0) != 0 or not _changed

    - name: Show rails-runner output
      ansible.builtin.debug:
        var: exec_out

    # ######################################
    # 2. PUZZLE SETUP (USER AND PROJECTS)
    # ######################################
    - name: Create 'riddle' user
      community.general.gitlab_user:
        api_url: "{{ gitlab_base_url }}"
        api_username: "root"
        api_password: "{{ new_gitlab_root_password }}"
        name: "User Riddle"
        username: "{{ riddle_username }}"
        email: "{{ riddle_email }}"
        password: "{{ riddle_user_password }}"
        state: "present"
      register: riddle_user_details

    - name: Extract riddle user ID for later use in CI/CD
      ansible.builtin.set_fact:
        riddle_user_id: "{{ riddle_user_details.user.id }}"

    # ######################################
    # NEU: 2.1 ADMIN PAT ERSTELLEN
    # ######################################
    - name: Create Admin Personal Access Token (PAT) via Rails Runner
      community.docker.docker_container_exec:
        container: "{{ gitlab_container_name }}"
        # Docker Host explizit setzen, um http+docker Fehler zu vermeiden
        docker_host: "unix:///var/run/docker.sock"
        # Dieser Rails-Befehl findet den root-User und erstellt einen PAT mit API-Scope
        command: >-
          gitlab-rails runner "user = User.find_by_username('root');
          token = user.personal_access_tokens.create(
            scopes: ['api'],
            name: 'ci_unlock_pat',
            expires_at: 365.days.from_now
          );
          puts token.token"
      register: admin_pat_raw
      changed_when: admin_pat_raw.stdout is defined and admin_pat_raw.stdout != ""

    - name: Extract Admin PAT value
      ansible.builtin.set_fact:
        # Trim entfernt eventuelle Leerzeilen
        gitlab_admin_pat: "{{ admin_pat_raw.stdout | trim }}"

    # ######################################
    # NEU: 2.2 ADMIN PAT ALS CI/CD VARIABLE SPEICHERN
    # ######################################
    - name: Create all puzzle repositories
      community.general.gitlab_project:
        api_url: "{{ gitlab_base_url }}"
        api_username: "root"
        api_password: "{{ new_gitlab_root_password }}"
        name: "{{ item.name }}"
        path: "{{ item.path }}"
        state: "present"
        visibility: "private"
        initialize_with_readme: true
      loop: "{{ puzzle_projects }}"

    - name: Set CI/CD variable GITLAB_ADMIN_TOKEN (required for unlock)
      community.general.gitlab_project_variable:
        api_url: "{{ gitlab_base_url }}"
        api_username: "root"
        api_password: "{{ new_gitlab_root_password }}"
        project: "root/{{ puzzle_projects[0].path }}"
        variables:
          - name: "GITLAB_ADMIN_TOKEN"
            value: "{{ gitlab_admin_pat }}"
            protected: true
            masked: true
        state: present

    - name: Set CI/CD variables required for unlocking next riddle
      community.general.gitlab_project_variable:
        api_url: "{{ gitlab_base_url }}"
        api_username: "root"
        api_password: "{{ new_gitlab_root_password }}"
        project: "root/{{ puzzle_projects[0].path }}" # Im ersten Rätsel speichern
        variables:
          - name: "RIDDLE_USER_ID"
            value: "{{ riddle_user_id }}"
            protected: true
          - name: "NEXT_RIDDLE_PATH"
            value: "{{ puzzle_projects[1].path }}"
            protected: true

    # !! muss man beim intiale setup machen weil url vl erst später erreichbar ist auch wenn container gitlab healthy
    # Fügen Sie DIESEN TASK VOR dem Klon-Task ein:
    # - name: Wait 30 seconds for GitLab Git services to stabilize
    #   ansible.builtin.pause:
    #     seconds: 30
    - name: Clone riddle-01 repository locally in Ansible container
      ansible.builtin.git:
        # Authentifizierung als root (mit dem neuen Passwort) über HTTP
        repo: "http://root:{{ new_gitlab_root_password }}@gitlab/root/{{ puzzle_projects[0].path }}.git"
        dest: "/tmp/riddle-01-repo" # Temporärer Klon-Pfad im Container
        version: "main"
        force: true
      # Benötigt python-gitlab nicht, verwendet das git-Binary

    - name: Copy initial files into cloned repository
      ansible.builtin.copy:
        # Pfad im Ansible-Container, wo Ihre Dateien liegen
        src: "/work/riddle-01-files/{{ item }}"
        dest: "/tmp/riddle-01-repo/{{ item }}"
        mode: "0755" # Setzt Ausführungsberechtigung für solve.sh
      loop:
        - .gitlab-ci.yml
        - solve.sh

    - name: Commit and push initial files to GitLab
      ansible.builtin.shell:
        cmd: |
          # Gehe in das geklonte Repo
          cd /tmp/riddle-01-repo
          # Globale Git-Config setzen (nur für diesen Commit)
          git config user.email "gitlab@local.lab"
          git config user.name "GitLab Seeder"
          git add .
          git commit -m "Initial riddle setup and CI pipeline."
          git push origin main
        executable: /bin/sh
      register: git_output
      # Markiert den Task als 'changed', wenn etwas gepusht wurde
      changed_when: "'Everything up-to-date' not in git_output.stdout"

    - name: Unprotect 'main' branch for Developer push access on ALL puzzles
      community.general.gitlab_protected_branch:
        api_url: "{{ gitlab_base_url }}"
        api_username: "root"
        api_password: "{{ new_gitlab_root_password }}"
        project: "root/{{ item.path }}"
        name: "main"
        state: present
        push_access_level: developer # Erlaubt Developern das Pushen
        merge_access_levels: developer # Erlaubt Developern das Mergen

      loop: "{{ puzzle_projects }}"

    - name: Grant 'riddle' Developer access to the first puzzle (riddle-01-start)
      community.general.gitlab_project_members:
        api_url: "{{ gitlab_base_url }}"
        api_username: "root"
        api_password: "{{ new_gitlab_root_password }}"
        project: "{{ puzzle_projects[0].path }}"
        gitlab_user: "{{ riddle_username }}"
        access_level: "developer"
        state: "present"

    # ######################################
    # 3. RUNNER SETUP
    # ######################################
    # --- NEUER TASK 1: Runner Token auslesen ---
    - name: Get the Instance Runner Registration Token
      community.docker.docker_container_exec:
        container: "{{ gitlab_container_name }}"
        # Dieser Befehl liest den globalen Runner-Registrierungs-Token aus
        # Dieser Befehl ist mit GitLab 17+ kompatibel
        command: >-
          gitlab-rails runner "puts Gitlab::CurrentSettings.current_application_settings.runners_registration_token"
      register: runner_token_raw
      changed_when: false

    # --- NEUER TASK 2: Token extrahieren ---
    - name: Extract runner token
      ansible.builtin.set_fact:
        # 'trim' entfernt eventuelle Leerzeilen/Zeilenumbrüche
        runner_token: "{{ runner_token_raw.stdout | trim }}"

    - name: Show new runner token
      ansible.builtin.debug:
        var: runner_token
        verbosity: 1

    - name: Ensure runner_init.sh is executable
      # Der Pfad /project/runner_init.sh referenziert die Datei
      # auf dem Host, da das /project-Volume gemountet ist.
      ansible.builtin.file:
        path: "/project/seedGitlab/runner_init.sh"
        mode: "0755" # Setzt die Ausführungsberechtigung (+x) für den Besitzer und die Gruppe

    # --- NEUER TASK 3: config.toml Datei schreiben ---
    - name: Write runner.env file for gitlab-runner service
      ansible.builtin.copy:
        # /project/ ist der Mount-Punkt für dein '.'-Verzeichnis auf dem Host
        dest: "{{ runner_env_path }}"
        mode: "0644"
        # Dies ist eine minimale, funktionierende config.toml
        content: |
          # Diese Datei wird von seed.yml automatisch generiert
          # WICHTIG: RUNNER_TOKEN (NICHT token=)
          RUNNER_TOKEN={{ runner_token }}

          # Diese Variablen werden ebenfalls vom Entrypoint gelesen:
          CI_SERVER_URL={{ gitlab_base_url }}
          RUNNER_EXECUTOR=docker
          DOCKER_IMAGE=alpine:3.20
          RUNNER_DESCRIPTION=local-docker-runner
          RUNNER_TAG_LIST=local,docker
          RUNNER_RUN_UNTAGGED=true
          RUNNER_LOCKED=false
      register: env_file_written

    - name: Show env file write status
      ansible.builtin.debug:
        var: env_file_written.dest
        verbosity: 1
